"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const typescript_1 = tslib_1.__importDefault(require("typescript"));
const config_1 = require("../config");
const utils = tslib_1.__importStar(require("../utils"));
const EXPORT_DEFAULT_FUNCTION = 1;
const EXPORT_DEFAULT = 2;
const EXPORT = 3;
const globalCache = {};
exports.defaultConfig = {
    // only need to parse config.default.ts or config.ts
    pattern: 'config(.default|).(ts|js)',
    interface: config_1.declMapping.config,
};
function default_1(config, baseConfig) {
    const fileList = config.fileList;
    const dist = path_1.default.resolve(config.dtsDir, 'index.d.ts');
    const cache = globalCache[baseConfig.id] = globalCache[baseConfig.id] || {};
    if (!fileList.length) {
        return { dist };
    }
    const importList = [];
    const declarationList = [];
    const moduleList = [];
    fileList.forEach(f => {
        const abUrl = path_1.default.resolve(config.dir, f);
        // read from cache
        if (!cache[abUrl] || config.file === abUrl) {
            const skipLibCheck = !!baseConfig.tsConfig.skipLibCheck;
            const { type, usePowerPartial } = checkConfigReturnType(abUrl);
            // skip when not usePowerPartial and skipLibCheck in ts file
            // because it maybe cause types error.
            if (path_1.default.extname(f) !== '.js' && !usePowerPartial && !skipLibCheck)
                return;
            const { moduleName: sModuleName } = utils.getModuleObjByPath(f);
            const moduleName = `Export${sModuleName}`;
            const importContext = utils.getImportStr(config.dtsDir, abUrl, moduleName, type === EXPORT);
            let tds = `type ${sModuleName} = `;
            if (type === EXPORT_DEFAULT_FUNCTION) {
                tds += `ReturnType<typeof ${moduleName}>;`;
            }
            else if (type === EXPORT_DEFAULT || type === EXPORT) {
                tds += `typeof ${moduleName};`;
            }
            else {
                return;
            }
            // cache the file
            cache[abUrl] = {
                import: importContext,
                declaration: tds,
                moduleName: sModuleName,
            };
        }
        const cacheItem = cache[abUrl];
        importList.push(cacheItem.import);
        declarationList.push(cacheItem.declaration);
        moduleList.push(cacheItem.moduleName);
    });
    if (!importList.length) {
        return { dist };
    }
    const newConfigType = `New${config.interface}`;
    return {
        dist,
        content: `import { ${config.interface} } from '${baseConfig.framework}';\n` +
            `${importList.join('\n')}\n` +
            `${declarationList.join('\n')}\n` +
            `type ${newConfigType} = ${moduleList.join(' & ')};\n` +
            `declare module '${baseConfig.framework}' {\n` +
            `  interface ${config.interface} extends ${newConfigType} { }\n` +
            '}',
    };
}
exports.default = default_1;
// check config return type.
function checkConfigReturnType(f) {
    const result = utils.findExportNode(fs_1.default.readFileSync(f, 'utf-8'));
    const resp = {
        type: undefined,
        usePowerPartial: false,
    };
    if (result.exportDefaultNode) {
        const exportDefaultNode = result.exportDefaultNode;
        if (typescript_1.default.isFunctionLike(exportDefaultNode)) {
            if ((typescript_1.default.isFunctionDeclaration(exportDefaultNode) || typescript_1.default.isArrowFunction(exportDefaultNode)) && exportDefaultNode.body) {
                exportDefaultNode.body.forEachChild(tNode => {
                    if (!resp.usePowerPartial && typescript_1.default.isVariableStatement(tNode)) {
                        // check wether use PowerPartial<EggAppInfo>
                        resp.usePowerPartial = !!tNode.declarationList.declarations.find(decl => {
                            let typeText = decl.type ? decl.type.getText() : undefined;
                            if (decl.initializer && typescript_1.default.isAsExpression(decl.initializer) && decl.initializer.type) {
                                typeText = decl.initializer.type.getText();
                            }
                            return !!(typeText && typeText.includes('PowerPartial') && typeText.includes('EggAppConfig'));
                        });
                    }
                });
            }
            resp.type = EXPORT_DEFAULT_FUNCTION;
        }
        else {
            resp.type = EXPORT_DEFAULT;
        }
    }
    else if (result.exportNodeList.length) {
        resp.type = EXPORT;
    }
    return resp;
}
exports.checkConfigReturnType = checkConfigReturnType;
//# sourceMappingURL=config.js.map