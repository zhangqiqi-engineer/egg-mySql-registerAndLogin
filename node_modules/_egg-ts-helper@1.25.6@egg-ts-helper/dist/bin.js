#! /usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const commander_1 = require("commander");
const assert_1 = tslib_1.__importDefault(require("assert"));
const package_json_1 = tslib_1.__importDefault(require("../package.json"));
const _1 = require("./");
const utils_1 = require("./utils");
const commands = utils_1.loadModules(path_1.default.resolve(__dirname, './cmd'), true);
let executeCmd;
// override executeSubCommand to support async subcommand.
commander_1.Command.prototype.addImplicitHelpCommand = () => { };
commander_1.Command.prototype.executeSubCommand = async function (argv, args, unknown) {
    const cwd = this.cwd || _1.defaultConfig.cwd;
    const command = commands[executeCmd];
    assert_1.default(command, executeCmd + ' does not exist');
    await command.run(this, { cwd, argv, args: args.filter(item => item !== this), unknown });
};
const program = new commander_1.Command()
    .version(package_json_1.default.version, '-v, --version')
    .usage('[commands] [options]')
    .option('-w, --watch', 'Watching files, d.ts would recreated while file changed')
    .option('-c, --cwd [path]', 'Egg application base dir (default: process.cwd)')
    .option('-C, --config [path]', 'Configuration file, The argument can be a file path to a valid JSON/JS configuration file.ï¼ˆdefault: {cwd}/tshelper.js')
    .option('-f, --framework [name]', 'Egg framework(default: egg)')
    .option('-o, --oneForAll [path]', 'Create a d.ts import all types (default: typings/ets.d.ts)')
    .option('-s, --silent', 'Running without output')
    .option('-i, --ignore [dirs]', 'Ignore watchDirs, your can ignore multiple dirs with comma like: -i controller,service')
    .option('-e, --enabled [dirs]', 'Enable watchDirs, your can enable multiple dirs with comma like: -e proxy,other')
    .option('-E, --extra [json]', 'Extra config, the value should be json string');
if (!process.argv.slice(2).length) {
    execute();
}
else {
    Object.keys(commands).forEach(cmd => {
        const subCommand = commands[cmd];
        const cmdName = subCommand.options ? `${cmd} ${subCommand.options}` : cmd;
        program.command(cmdName, subCommand.description)
            .action(command => executeCmd = command);
    });
    program.parse(process.argv);
    if (!executeCmd) {
        execute();
    }
}
// execute fn
function execute() {
    const watchFiles = program.watch;
    const watchDirs = {};
    (program.ignore || '').split(',').forEach(key => (watchDirs[key] = false));
    (program.enabled || '').split(',').forEach(key => (watchDirs[key] = true));
    const tsHelperConfig = Object.assign({ cwd: program.cwd || _1.defaultConfig.cwd, framework: program.framework, watch: watchFiles, watchDirs, configFile: program.config }, (program.extra ? JSON.parse(program.extra) : {}));
    // silent
    if (program.silent) {
        tsHelperConfig.silent = true;
    }
    if (utils_1.checkMaybeIsJsProj(tsHelperConfig.cwd)) {
        // write jsconfig if the project is wrote by js
        utils_1.writeJsConfig(tsHelperConfig.cwd);
    }
    // create instance
    const tsHelper = _1.createTsHelperInstance(tsHelperConfig).build();
    if (program.oneForAll) {
        // create one for all
        tsHelper.createOneForAll(program.oneForAll);
    }
}
//# sourceMappingURL=bin.js.map