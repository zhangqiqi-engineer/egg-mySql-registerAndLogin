"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cluster_1 = tslib_1.__importDefault(require("cluster"));
const debug_1 = tslib_1.__importDefault(require("debug"));
const dot_prop_1 = require("dot-prop");
const _1 = require("./");
const util = tslib_1.__importStar(require("./utils"));
const debug = debug_1.default('egg-ts-helper#register');
/* istanbul ignore else */
if (cluster_1.default.isMaster) {
    // make sure ets only run once
    const pid = process.env.ETS_REGISTER_PID;
    if (pid) {
        debug('egg-ts-helper watcher has ran in %s', pid);
    }
    else {
        register(util.convertString(process.env.ETS_WATCH, process.env.NODE_ENV !== 'test'));
    }
}
// start to register
function register(watch) {
    const cwd = process.cwd();
    if (util.checkMaybeIsJsProj(cwd)) {
        // write jsconfig if the project is wrote by js
        util.writeJsConfig(cwd);
    }
    else {
        const tsNodeMode = dot_prop_1.get(util.getPkgInfo(cwd), 'egg.typescript') ||
            process.argv.includes('--ts') ||
            process.argv.includes('--typescript') ||
            process.env.EGG_TYPESCRIPT === 'true';
        // no need to clean in js project
        // clean local js file at first.
        // because egg-loader cannot load the same property name to egg.
        if (tsNodeMode) {
            util.cleanJs(cwd);
        }
    }
    if (watch) {
        // cache pid to env, prevent child process executing ets again
        process.env.ETS_REGISTER_PID = `${process.pid}`;
    }
    // exec building
    _1.createTsHelperInstance({ watch }).build();
}
//# sourceMappingURL=register.js.map